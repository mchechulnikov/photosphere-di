<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
var dependencies = new string[] { "IResolver", "IScopeKeeper" };

string GetProjectPath()
{
	var currentPath = Host.ResolvePath(string.Empty);
	var rawProjectPath = Path.Combine(currentPath, "..\\");
	return Path.GetFullPath(rawProjectPath).Replace("\\", "\\\\");
}

string[] GetAllCsFiles() => Directory.GetFiles(GetProjectPath(), "*.cs", SearchOption.AllDirectories);

string GetClassName(string content)
{
	var value = new Regex("class [a-zA-Z0-9]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(6);
}

bool IsStaticClass(string content)
{
	var value = new Regex("static class").Match(content).Value;
	return value != string.Empty;
}

bool IsAbstractClass(string content)
{
	var value = new Regex("abstract class").Match(content).Value;
	return value != string.Empty;
}

string GetNamespace(string content)
{
	var value = new Regex("namespace [a-zA-Z0-9.]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(10);
}

string[] GetBaseTypesNames(string content)
{
	var value = new Regex(": [a-zA-Z0-9]+").Match(content).Value;
	return value == string.Empty
		? null
		: value.TrimStart(':').TrimStart().Replace(",", string.Empty).Split(' ');
}

string[] GetCtorParametersTypes(string content, string className)
{
	var value = new Regex(className + "(\\s)*\\(((\\s)*[(this) \\w=]+,*(\\s)*)+").Match(content).Value;
	if (value == string.Empty)
	{
		return null;
	}
	var result = value
		.Replace(className + "(", string.Empty)
		.Replace(")", string.Empty)
        .Replace("this ", string.Empty)
        .Split(',')
        .Select(x => x.Trim())
        .Select(x => x.Split(' ').First())
		.Where(x => !string.IsNullOrEmpty(x)).ToArray();
	if (result.Count() == 0)
	{
		return null;
	}
	return result;
}

Tuple<string, string, string[], string[]> ParseCs(string content)
{
	var className = GetClassName(content);
	if (className == null)
	{
		return null;
	}
	if (IsStaticClass(content))
	{
		return null;
	}
	if (IsAbstractClass(content))
	{
		return null;
	}
	var baseTypesNames = GetBaseTypesNames(content);
	if (baseTypesNames != null && baseTypesNames.Contains("Attribute"))
	{
		return null;
	}
	return new Tuple<string, string, string[], string[]>(
		className,
		GetNamespace(content),
		baseTypesNames,
		GetCtorParametersTypes(content, className)
	);
}

IReadOnlyList<Tuple<string, string, string[], string[]>> GetTypes() =>
	GetAllCsFiles()
	.Select(File.ReadAllText)
	.Select(ParseCs)
	.Where(info => info != null).ToList();

var typesInfos = GetTypes();

string GetVariableName(string className) =>
	char.ToLowerInvariant(className[0]) + className.Substring(1);

Tuple<string, string, string[], string[]> GetClassInfoByBaseTypeName(
	string baseTypeName,
	IReadOnlyList<Tuple<string, string, string[], string[]>> types
)
{
	return types.First(x => x.Item3.Contains(baseTypeName));
}

bool Contains(string[] source, string[] target)
{
	foreach(var item in target)
	{
		if (source.Contains(item))
		{
			return true;
		}
	}
	return false;
}

#>
using System;
using System.Collections.Generic;
<# foreach (var namespaceString in typesInfos.Select(t => t.Item2).Where(n => n != null).Distinct()) { #>
using <#= namespaceString #>;
<# } #>

namespace Photosphere.DependencyInjection.InnerStructure
{
	internal class ServiceLocator
	{
		private readonly IContainerConfiguration _configuration;
		private readonly IDictionary<Type, object> _map = new Dictionary<Type, object>();

		public ServiceLocator(IContainerConfiguration configuration)
		{
			_configuration = configuration;

<#
var alreadyActivated = new HashSet<string>();
foreach (var type in typesInfos.Where(x => x.Item3 != null && Contains(x.Item3, dependencies)))
{
	var paramList = new List<string>();
	var serviceName = dependencies.First(x => type.Item3.Contains(x));
	if (type.Item4 != null)
	{
		foreach (var parameterClassInfo in type.Item4.Select(pt => typesInfos.First(x => x.Item3 != null && x.Item3.Contains(pt))))
		{
			var varName = GetVariableName(parameterClassInfo.Item1);
			paramList.Add(varName);
			if (alreadyActivated.Contains(varName)) 
			{
				continue;
			}
#>
			var <#= varName #> = new <#= parameterClassInfo.Item1 #>();
<#			alreadyActivated.Add(varName);
		} #>
			var <#= GetVariableName(type.Item1) #> = new <#= type.Item1 #>(<#= string.Join(", ", paramList) #>);
<#	}
	else
	{
		var varName = GetVariableName(type.Item1);
		alreadyActivated.Add(varName); #>
			var <#= varName #> = new <#= type.Item1 #>();
<#	} #>
			_map.Add(typeof (<#= serviceName #>), <#= GetVariableName(type.Item1) #>);
<#
}
#>
		}

		public T Get<T>() where T : class => (T) _map[typeof(T)];
	}
}
