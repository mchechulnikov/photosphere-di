<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
string GetProjectPath()
{
	var currentPath = Host.ResolvePath(string.Empty);
	var rawProjectPath = Path.Combine(currentPath, "..\\");
	return Path.GetFullPath(rawProjectPath).Replace("\\", "\\\\");
}

string[] GetAllCsFiles() => Directory.GetFiles(GetProjectPath(), "*.cs", SearchOption.AllDirectories);

string GetClassName(string content)
{
	var value = new Regex("class [a-zA-Z0-9]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(6);
}

bool IsStaticClass(string content)
{
	var value = new Regex("static class").Match(content).Value;
	return value != string.Empty;
}

bool IsAbstractClass(string content)
{
	var value = new Regex("abstract class").Match(content).Value;
	return value != string.Empty;
}

string GetNamespace(string content)
{
	var value = new Regex("namespace [a-zA-Z0-9.]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(10);
}

string[] GetBaseTypesNames(string content)
{
	var value = new Regex(": [a-zA-Z0-9]+").Match(content).Value;
	return value == string.Empty
		? null
		: value.TrimStart(':').TrimStart().Replace(",", string.Empty).Split(' ');
}

string[] GetCtorParametersTypes(string content, string className)
{
	var value = new Regex(className + "(\\s)*\\(((\\s)*[(this) \\w=]+,*(\\s)*)+").Match(content).Value;
	if (value == string.Empty)
	{
		return null;
	}
	var result = value
		.Replace(className + "(", string.Empty)
		.Replace(")", string.Empty)
        .Replace("this ", string.Empty)
        .Split(',')
        .Select(x => x.Trim())
        .Select(x => x.Split(' ').First())
		.Where(x => !string.IsNullOrEmpty(x)).ToArray();
	if (result.Count() == 0)
	{
		return null;
	}
	return result;
}

Tuple<string, string, string[], string[]> ParseCs(string content)
{
	var className = GetClassName(content);
	if (className == null)
	{
		return null;
	}
	if (IsStaticClass(content))
	{
		return null;
	}
	if (IsAbstractClass(content))
	{
		return null;
	}
	var baseTypesNames = GetBaseTypesNames(content);
	if (baseTypesNames != null && baseTypesNames.Contains("Attribute"))
	{
		return null;
	}
	return new Tuple<string, string, string[], string[]>(
		className,
		GetNamespace(content),
		baseTypesNames,
		GetCtorParametersTypes(content, className)
	);
}

IReadOnlyList<Tuple<string, string, string[], string[]>> GetTypes() =>
	GetAllCsFiles()
	.Select(File.ReadAllText)
	.Select(ParseCs)
	.Where(info => info != null).ToList();

var typesInfos = GetTypes();

string GetVariableName(string className) =>
	char.ToLowerInvariant(className[0]) + className.Substring(1);

Tuple<string, string, string[], string[]> GetClassInfoByBaseTypeName(
	string baseTypeName,
	IReadOnlyList<Tuple<string, string, string[], string[]>> types
)
{
	return types.First(x => x.Item3.Contains(baseTypeName));
}

#>
using System;
using System.Collections.Generic;
<# foreach (var namespaceString in typesInfos.Select(t => t.Item2).Where(n => n != null).Distinct()) { #>
using <#= namespaceString #>;
<# } #>

namespace Photosphere.DependencyInjection.InnerStructure
{
	internal class ServiceLocator
	{
		private readonly IContainerConfiguration _configuration;
		private readonly IDictionary<Type, Type[]> _map = new Dictionary<Type, Type[]>
		{
<# foreach (var type in typesInfos) { #>
			{ typeof (<#= type.Item1 #>), null },
<# } #>
		};

		public ServiceLocator(IContainerConfiguration configuration)
		{
			_configuration = configuration;

<#
foreach (var type in typesInfos.Where(x => x.Item3 != null && x.Item3.Contains("IResolver"))) {
var paramList = new List<string>();
foreach (var parameterClassInfo in type.Item4.Select(pt => typesInfos.First(x => x.Item3 != null && x.Item3.Contains(pt)))) {
var varName = GetVariableName(parameterClassInfo.Item1);
paramList.Add(varName);
#>
			var <#= varName #> = new <#= parameterClassInfo.Item1 #>();
<# } #>
			var <#= GetVariableName(type.Item1) #> = new <#= type.Item1 #>(<#= string.Join(", ", paramList) #>);
<# } #>
		}

		public T Get<T>() where T : class => null;
	}
}
