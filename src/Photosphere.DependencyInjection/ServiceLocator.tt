<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
var dependencies = new string[] { "IRegistryInitializer", "IResolver", "IScopeKeeper" };

string GetProjectPath()
{
	var currentPath = Host.ResolvePath(string.Empty);
	return Path.GetFullPath(currentPath).Replace("\\", "\\\\");
}

string[] GetAllCsFiles() => Directory.GetFiles(GetProjectPath(), "*.cs", SearchOption.AllDirectories);

string GetClassName(string content)
{
	var value = new Regex("class [a-zA-Z0-9]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(6);
}

bool IsStaticClass(string content)
{
	var value = new Regex("static class").Match(content).Value;
	return value != string.Empty;
}

bool IsAbstractClass(string content)
{
	var value = new Regex("abstract class").Match(content).Value;
	return value != string.Empty;
}

string GetNamespace(string content)
{
	var value = new Regex("namespace [a-zA-Z0-9.]+").Match(content).Value;
	return value == string.Empty ? null : value.Substring(10);
}

string[] GetBaseTypesNames(string content)
{
	var value = new Regex(":\\s*([a-zA-Z0-9]+,*\\s*)+").Match(content).Value;
	if (value == string.Empty)
	{
		return null;
	}
	var result = value.TrimStart(':').Trim().Replace(",", string.Empty);
	if (!result.Contains(" "))
	{
		return new [] { result };
	}
	return result.Split(' ');
}

string[] GetCtorParametersTypes(string content, string className)
{
	var value = new Regex(className + "\\s*\\((\\s*[(this) \\w=]+,*\\s*)+").Match(content).Value;
	if (value == string.Empty)
	{
		return null;
	}
	var result = value
		.Trim()
		.Replace(className + "(", string.Empty)
		.Replace(")", string.Empty)
        .Replace("this ", string.Empty)
        .Split(',')
        .Select(x => x.Trim())
        .Select(x => x.Split(' ').First())
		.Where(x => !string.IsNullOrEmpty(x)).ToArray();
	if (result.Count() == 0)
	{
		return null;
	}
	return result;
}

Tuple<string, string, string[], string[]> ParseCs(string content)
{
	var className = GetClassName(content);
	if (className == null)
	{
		return null;
	}
	if (IsStaticClass(content))
	{
		return null;
	}
	if (IsAbstractClass(content))
	{
		return null;
	}
	var baseTypesNames = GetBaseTypesNames(content);
	if (baseTypesNames != null && baseTypesNames.Contains("Attribute"))
	{
		return null;
	}
	return new Tuple<string, string, string[], string[]>(
		className,
		GetNamespace(content),
		baseTypesNames,
		GetCtorParametersTypes(content, className)
	);
}

IReadOnlyList<Tuple<string, string, string[], string[]>> GetTypes() =>
	GetAllCsFiles()
	.Select(File.ReadAllText)
	.Select(ParseCs)
	.Where(info => info != null).ToList();

var typesInfos = GetTypes();

string GetVariableName(string className) =>
	char.ToLowerInvariant(className[0]) + className.Substring(1);

Tuple<string, string, string[], string[]> GetClassInfoByBaseTypeName(
	string baseTypeName,
	IReadOnlyList<Tuple<string, string, string[], string[]>> types
)
{
	return types.First(x => x.Item3.Contains(baseTypeName));
}

bool Contains(string[] source, string[] target)
{
	foreach(var item in target)
	{
		if (source.Contains(item))
		{
			return true;
		}
	}
	return false;
}

#>
<#
void Recursive(string className0, string[] parametersTypes, HashSet<string> alreadyActivatedList)
{
	var paramList = new List<string>();	
	if (parametersTypes == null) 
	{
#>
			var <#= GetVariableName(className0) #> = new <#= className0 #>();
<#	
		return;
	}
	foreach (
		var parameterClassInfo in parametersTypes
			.Select(pt => typesInfos.FirstOrDefault(x => x.Item3 != null && x.Item3.Contains(pt))).Where(x => x != null)
	)
	{
		var varName = GetVariableName(parameterClassInfo.Item1);
		paramList.Add(varName);

		if (alreadyActivatedList.Contains(varName)) 
		{
			continue;
		}
		alreadyActivatedList.Add(varName);
		Recursive(parameterClassInfo.Item1, parameterClassInfo.Item4, alreadyActivatedList);
	}
#>
			var <#= GetVariableName(className0) #> = new <#= className0 #>(<#= string.Join(", ", paramList) #>);
<#
}
#>
using System;
using System.Collections.Generic;
<#
foreach (var namespaceString in typesInfos.Select(t => t.Item2).Where(n => n != null).Distinct())
{ #>
using <#= namespaceString #>;
<# } #>

namespace Photosphere.DependencyInjection.InnerStructure
{
	internal class ServiceLocator
	{
		private readonly IDictionary<Type, object> _map = new Dictionary<Type, object>();

		public ServiceLocator(IContainerConfiguration containerConfiguration)
		{
<#
var alreadyActivated = new HashSet<string>();
alreadyActivated.Add("containerConfiguration");

foreach (var type in typesInfos.Where(x => x.Item3 != null && Contains(x.Item3, dependencies)))
{
	var serviceName = dependencies.First(x => type.Item3.Contains(x));
	if (type.Item4 != null)
	{
		Recursive(type.Item1, type.Item4, alreadyActivated);
	}
	else
	{
		var varName = GetVariableName(type.Item1);
		if (!alreadyActivated.Contains(varName)) 
		{
#>
			var <#= varName #> = new <#= type.Item1 #>();
<#
			continue;
		}
		alreadyActivated.Add(varName);
	} #>
			_map.Add(typeof (<#= serviceName #>), <#= GetVariableName(type.Item1) #>);
<#
}
#>
		}

		public T Get<T>() where T : class => (T) _map[typeof(T)];
	}
}
